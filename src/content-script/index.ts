import ExpiryMap from 'expiry-map'
import 'github-markdown-css'
import Browser from 'webextension-polyfill'
import { captureEvent, identify } from '../analytics'
import { GptRateLimit, QueueThreshold, getUserConfig } from '../config'

const MSGTYPE_TEXT = 'MSGTYPE_TEXT'
const COPYRIGHT = 'Generated by GPT'
const HAS_RATELIMIT = true
const SHOW_COPYRIGHT = false

// æé—®æ¬¡æ•°é™åˆ¶
let gptRateLimit: GptRateLimit = GptRateLimit.R5
let queueThreshold: QueueThreshold = QueueThreshold.T5
const cache = new ExpiryMap(10 * 60 * 1000)
const messageQueue: any[] = []
let isProcessing = false

function registerFileHelperHook(hook: string) {
  const script = hook + '.js'

  const s = document.createElement('script')
  s.type = 'text/javascript'
  s.src = Browser.runtime.getURL(script)
  s.async = true
  document.head.appendChild(s)
}

// è°ƒç”¨GPTèŽ·å¾—é—®é¢˜å“åº”
function callGpt(message: any) {
  isProcessing = true
  const { uuid, nickname, text } = message

  console.info(`ðŸ¤– Trigger GPT: ${text}`)
  const port = Browser.runtime.connect()
  const listener = (response: any) => {
    isProcessing = false
    if (response && response.reply) {
      reply(response)
      captureEvent('chatgpt:response:success', { ...response })
    } else if (response.error) {
      response.reply = `æŠ±æ­‰å‡ºé”™å•¦ï¼Œé”™è¯¯ä»£ç ï¼š${response.error}ï¼Œè¯·åˆ°å¼€å‘è€…ç½‘ç«™çœ‹ä¸€ä¸‹å§https://chatgpt4filehelper.aow.me`
      reply(response)
      captureEvent('chatgpt:response:error', { ...response })
    } else {
      console.error('Call ChatGPT EXCEPTION')
    }
  }
  port.onMessage.addListener(listener)
  port.postMessage({
    actualSender: uuid || 'filehelper',
    nickname: nickname,
    uuid: uuid,
    question: text,
  })
  return () => {
    port.onMessage.removeListener(listener)
    port.disconnect()
  }
}

// å›žç­”å½“å‰é˜Ÿåˆ—ä¸­çš„ç¬¬ä¸€ä¸ªæ¶ˆæ¯
function processNext() {
  // å¦‚æžœé˜Ÿåˆ—ä¸ºç©ºï¼Œç»“æŸå‡½æ•°
  if (messageQueue.length === 0) {
    return;
  }

  // å–å‡ºé˜Ÿåˆ—ä¸­çš„ç¬¬ä¸€ä¸ªæ¶ˆæ¯ï¼Œå¹¶å›žç­”
  const message = messageQueue.shift();
  callGpt(message);
}

// å›žç­”æ¶ˆæ¯ï¼Œå¹¶åœ¨å›žç­”å®ŒåŽè°ƒç”¨ processNext å¤„ç†ä¸‹ä¸€ä¸ª
function reply(response: any) {
  console.info('ðŸ˜€ ChatGPT response: ', response)

  let content = response.reply
  if (content && content.length > 0) {
    content = content.trim();

    // æ˜¯å¦ç¾¤ç»„æ¶ˆæ¯
    if (SHOW_COPYRIGHT) {
      content = `${content}\n${COPYRIGHT}`
    }

    const msg = {
      MsgTypeText: MSGTYPE_TEXT,
      Content: content,
    }

    const event = new CustomEvent('filehelper:message:gpt_reply', {
      detail: msg,
    })

    window.dispatchEvent(event)
  }

  // å¤„ç†ä¸‹ä¸€æ¡æ¶ˆæ¯
  processNext()
}

// å‘é€ä¸€æ¡æ¶ˆæ¯å‘ŠçŸ¥å½“å‰æŽ’é˜Ÿäººæ•°
function notifyQueueStatus(queueLength: number) {
  const msg = {
    MsgTypeText: MSGTYPE_TEXT,
    Content: `å“Žå‘€ï¼Œæˆ‘è¿˜æœ‰${queueLength}ä¸ªé—®é¢˜è¦å›žç­”å‘¢ï¼Œè®©æˆ‘æ­‡ä¼šå„¿å§~~`,
  }

  const event = new CustomEvent('filehelper:message:gpt_reply', {
    detail: msg,
  })

  window.dispatchEvent(event)
}

window.addEventListener(
  'filehelper:user:session',
  (e: any) => {
    const msg = e.detail;
    // console.info(`User: ${msg.uuid}, detail: `, msg)
    identify(msg)
  },
  false,
)

window.addEventListener(
  'filehelper:message:add',
  (e: any) => {
    console.info('Got a new @gpt message', e.detail)
    if (HAS_RATELIMIT && !withRateLimitSatisfied("fileHelper")) {
      const response = {
        reply: 'æŠ±æ­‰ï¼Œä½ çš„æé—®å¤ªé¢‘ç¹äº†ï¼Œè¯·ç­‰ä¸€ä¼šå„¿å†æ¥é—®å§~',
      }
      reply(response)
      return
    }

    // å¦‚æžœé˜Ÿåˆ—ä¸ºç©ºä¸”æ²¡æœ‰æ­£åœ¨å¤„ç†ä¸­çš„é—®é¢˜ï¼Œæ— åˆ™ç›´æŽ¥å›žç­”
    if (!isProcessing && messageQueue.length === 0) {
      callGpt(e.detail);
    }
    // å¦åˆ™åŠ å…¥é˜Ÿåˆ—æŽ’é˜Ÿ
    else {
      messageQueue.push(e.detail);
      // å¦‚æžœé˜Ÿåˆ—é•¿åº¦è¶…è¿‡é˜ˆå€¼ï¼Œå‘é€ä¸€æ¡æ¶ˆæ¯å‘ŠçŸ¥å½“å‰æŽ’é˜Ÿé—®é¢˜æ•°é‡
      if (messageQueue.length > queueThreshold) {
        notifyQueueStatus(messageQueue.length);
      }
    }
  },
  false,
)

function withRateLimitSatisfied(actualSender: string) {
  const count = cache.get(actualSender) || 0

  if (count < gptRateLimit) {
    cache.set(actualSender, count + 1)
    return true
  }

  return false
}

async function loadUserConfig() {
  let userConfig = await getUserConfig();
  // æé—®æ¬¡æ•°é¢‘çŽ‡é™åˆ¶
  gptRateLimit = userConfig.gptRateLimit || GptRateLimit.R5
  // é˜Ÿåˆ—ç§¯åŽ‹æ¶ˆæ¯é€šæŠ¥é˜ˆå€¼
  queueThreshold = userConfig.queueThreshold || QueueThreshold.T5

  // ç›‘å¬é…ç½®å˜åŒ–
  Browser.storage.onChanged.addListener(async (changes, area) => {
    if (area === 'local' && changes.gptRateLimit?.newValue) {
      const newVaule = parseInt(changes.gptRateLimit.newValue);
      console.debug('New GptRateLimit Value', newVaule);
      gptRateLimit = newVaule || GptRateLimit.R5
    }

    if (area === 'local' && changes.queueThreshold?.newValue) {
      const newVaule = parseInt(changes.queueThreshold.newValue);
      console.debug('New QueueThreshold Value', newVaule);
      gptRateLimit = newVaule || QueueThreshold.T5
    }
  });
}

console.log('DOM loaded and register fileHelper hook.')
registerFileHelperHook('hook')
loadUserConfig().then(() => {
  console.log('Load user config completed.')
})
